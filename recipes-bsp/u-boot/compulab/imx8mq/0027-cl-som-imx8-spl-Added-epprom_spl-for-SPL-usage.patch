From 634cdb1afad7ab196ef4eae5973d6f89a08f0bf7 Mon Sep 17 00:00:00 2001
From: Valentin Raevsky <valentin@compulab.co.il>
Date: Wed, 30 Oct 2019 17:29:39 +0200
Subject: [PATCH 27/32] cl-som-imx8: spl: Added epprom_spl for SPL usage

Added epprom_spl.
Will be used for saving the ddr detected values from the SPL.

Signed-off-by: Valentin Raevsky <valentin@compulab.co.il>
---
 board/compulab/cl-som-imx8/Makefile     |   1 +
 board/compulab/cl-som-imx8/eeprom_spl.c | 124 ++++++++++++++++++++++++++++++++
 2 files changed, 125 insertions(+)
 create mode 100644 board/compulab/cl-som-imx8/eeprom_spl.c

diff --git a/board/compulab/cl-som-imx8/Makefile b/board/compulab/cl-som-imx8/Makefile
index 35caf15..920610d 100644
--- a/board/compulab/cl-som-imx8/Makefile
+++ b/board/compulab/cl-som-imx8/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_POWER_PFUZE100) += ../../freescale/common/pfuze.o
 
 ifdef CONFIG_SPL_BUILD
 obj-y += spl.o ddr/lpddr4_timing_1g.o ddr/lpddr4_timing_2g.o
+obj-y += eeprom_spl.o
 else
 obj-y += cl-som-imx8.o eeprom.o
 endif
diff --git a/board/compulab/cl-som-imx8/eeprom_spl.c b/board/compulab/cl-som-imx8/eeprom_spl.c
new file mode 100644
index 0000000..944cab1
--- /dev/null
+++ b/board/compulab/cl-som-imx8/eeprom_spl.c
@@ -0,0 +1,124 @@
+/*
+ * (C) Copyright 2019 CompuLab, Ltd. <www.compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <linux/kernel.h>
+#include <asm/arch/imx8mq_pins.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm-generic/gpio.h>
+#include <asm/setup.h>
+#include "eeprom.h"
+
+#define CONFIG_SYS_I2C_EEPROM_ADDR_P1	0x51
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+
+#ifndef CONFIG_SYS_I2C_EEPROM_BUS
+#define CONFIG_SYS_I2C_EEPROM_BUS	1
+#endif
+
+static int cl_eeprom_bus = CONFIG_SYS_I2C_EEPROM_BUS;
+
+static iomux_v3_cfg_t const eeprom_pads[] = {
+	IMX8MQ_PAD_GPIO1_IO13__GPIO1_IO13 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#define EEPROM_WP_GPIO IMX_GPIO_NR(1, 13)
+
+static void cl_eeprom_we(int enable)
+{
+	static int done = 0;
+
+	if (done) {
+		gpio_direction_output(EEPROM_WP_GPIO, enable);
+		return;
+	}
+
+	imx_iomux_v3_setup_multiple_pads(
+		eeprom_pads, ARRAY_SIZE(eeprom_pads));
+	gpio_request(EEPROM_WP_GPIO, "eeprom_wp");
+	gpio_direction_output(EEPROM_WP_GPIO, enable);
+	done = 1;
+}
+
+static int cl_eeprom_read(uint offset, uchar *buf, int len)
+{
+	int res;
+
+	i2c_set_bus_num(cl_eeprom_bus);
+
+	res = i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR_P1, offset,
+			CONFIG_SYS_I2C_EEPROM_ADDR_LEN, buf, len);
+
+	return res;
+}
+
+static int cl_eeprom_write(uint offset, uchar *buf, int len)
+{
+	int res;
+
+	cl_eeprom_we(1);
+
+	i2c_set_bus_num(cl_eeprom_bus);
+
+	res = i2c_write(CONFIG_SYS_I2C_EEPROM_ADDR_P1, offset,
+			CONFIG_SYS_I2C_EEPROM_ADDR_LEN, buf, len);
+
+	/*cl_eeprom_we(0);*/
+
+	return res;
+}
+
+/* Reserved for fututre use area */
+#define BOARD_DDRINFO_OFFSET 0x40
+#define BOARD_DDRINFO_SIZE 4
+static u32 board_ddrinfo = 0xdeadbeef;
+
+#define BOARD_DRATE_OFFSET 0x50
+#define BOARD_DRATE_SIZE 4
+static u32 board_drate = 0xdeadbeef;
+
+#define BOARD_DDRINFO_VALID(A) (A != 0xdeadbeef)
+
+u32 cl_eeprom_get_ddrinfo(void)
+{
+	if (!BOARD_DDRINFO_VALID(board_ddrinfo)) {
+		if (cl_eeprom_read(BOARD_DDRINFO_OFFSET, (uchar *)&board_ddrinfo, BOARD_DDRINFO_SIZE))
+			return 0;
+	}
+	return board_ddrinfo;
+};
+
+u32 cl_eeprom_set_ddrinfo(u32 ddrinfo)
+{
+	if (cl_eeprom_write(BOARD_DDRINFO_OFFSET, (uchar *)&ddrinfo, BOARD_DDRINFO_SIZE))
+		return 0;
+
+	board_ddrinfo = ddrinfo;
+
+	return board_ddrinfo;
+};
+
+#define DRATE_OFFSET(R,C) (BOARD_DRATE_OFFSET + ( 0x10 * (R) ) + ( (C) << 2 ))
+u32 cl_eeprom_get_drate(unsigned int r, unsigned int c)
+{
+	if (cl_eeprom_read(DRATE_OFFSET(r,c) , (uchar *)&board_drate, BOARD_DRATE_SIZE))
+		return 0;
+
+	return board_drate;
+};
+
+u32 cl_eeprom_set_drate(u32 drate, unsigned int r, unsigned int c)
+{
+	if (cl_eeprom_write(DRATE_OFFSET(r,c), (uchar *)&drate, BOARD_DRATE_SIZE))
+		return 0;
+
+	board_drate = drate;
+
+	udelay(5000);
+
+	return board_drate;
+};
-- 
1.9.1

