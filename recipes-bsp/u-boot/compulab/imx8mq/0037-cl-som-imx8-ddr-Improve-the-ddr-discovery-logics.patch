From eeadd96073fb56d0671e718b46438482b35dfe13 Mon Sep 17 00:00:00 2001
From: Valentin Raevsky <valentin@compulab.co.il>
Date: Mon, 2 Mar 2020 20:11:30 +0200
Subject: [PATCH 37/37] cl-som-imx8: ddr: Improve the ddr discovery logics

1) Implemented a tcm ddrid scan mode, that allows save a detected ddrid
between the configurations' attempts. Each memory detection attempt uses
different ddr settings from the ddr timing array. It allows using the
ddr correct setting for reading the mr5-8 registers. Maximum attempt's
count is the lpddr4_desc array size. Stop in SPL if no timings found for
a discovered ddrid.

2) Removed the eeprom wp limitation. If the SoM eeprom is locked then don't
count on the eeprom value and issue the ddr discovery each reboot.

3) Added lpddr4 read retries in case of an incorrect value was returned in
the mr5-8.

4) Removed unused stuff.

Signed-off-by: Valentin Raevsky <valentin@compulab.co.il>
---
 board/compulab/cl-som-imx8/ddr/ddr.c | 192 +++++++++++++++++------------------
 1 file changed, 93 insertions(+), 99 deletions(-)

diff --git a/board/compulab/cl-som-imx8/ddr/ddr.c b/board/compulab/cl-som-imx8/ddr/ddr.c
index c9dccbe..1a0dc21 100644
--- a/board/compulab/cl-som-imx8/ddr/ddr.c
+++ b/board/compulab/cl-som-imx8/ddr/ddr.c
@@ -25,20 +25,6 @@ u32 cl_eeprom_get_osize(void);
 
 unsigned int lpddr4_mr_read(unsigned int mr_rank, unsigned int mr_addr);
 
-static iomux_v3_cfg_t const cfg_pads[] = {
-    IMX8MQ_PAD_UART4_TXD__GPIO5_IO29| MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-#define CFG_GPIO IMX_GPIO_NR(5, 29)
-static int spl_ddr_cfg_mode(void)
-{
-    unsigned int cfg_gpio;
-    imx_iomux_v3_setup_multiple_pads(cfg_pads, ARRAY_SIZE(cfg_pads));
-    gpio_request(CFG_GPIO, "cfg_gpio");
-    cfg_gpio = gpio_get_value(CFG_GPIO);
-    return cfg_gpio;
-}
-
 struct lpddr4_desc {
 	char name[16];
 	unsigned int id;
@@ -52,14 +38,19 @@ struct lpddr4_desc {
 	char *desc[4];
 };
 
+struct lpddr4_tcm_desc {
+	unsigned int size;
+	unsigned int sign;
+	unsigned int index;
+	unsigned int count;
+};
+
 #define DEFAULT (('D' << 24) + ('E' << 16 ) + ( 'F' << 8 ) + 'A')
 static const struct lpddr4_desc lpddr4_array_2op[] = {
 	{ .name = "Micron", .id = 0xFF020008, .size = 2048, .count = 1, .timing = { &dram_timing_2g } },
 	{ .name = "Samsung",.id = 0x01050008, .size = 1024, .count = 1, .timing = { &dram_timing_1g } },
 	{ .name = "Nanya",  .id = 0x05000008, .size = 1024, .count = 1, .timing = { &dram_timing_1g} },
 	{ .name = "Nanya", . id = 0x05000010, .size = 2048, .count = 1, .timing = { &dram_timing_05_10_2g} },
-	/* deafult value, for reading mr5-8 */
-	{ .name = "Default", .id = DEFAULT,  .size = 1024, .timing = { &dram_timing_1g } },
 };
 
 static const struct lpddr4_desc lpddr4_array_3op[] = {
@@ -68,48 +59,57 @@ static const struct lpddr4_desc lpddr4_array_3op[] = {
 	{ .name = "Samsung",.id = 0x01061010, .size = 2048, .count = 1, .timing = { &dram_timing_05_10_2g_3op} },
 	{ .name = "Nanya",  .id = 0x05000008, .size = 1024, .count = 1, .timing = { &dram_timing_1g_3op } },
 	{ .name = "Nanya",  .id = 0x05000010, .size = 2048, .count = 1, .timing = { &dram_timing_05_10_2g_3op} },
-	/* deafult value, for reading mr5-8 */
-	{ .name = "Default", .id = DEFAULT,  .size = 1024, .timing = { &dram_timing_1g_3op } },
 };
 
-#define TCM_DATA_CFG 0x7e0000
-static void set_tcm_data(unsigned int data)
-{
-	writel(data, TCM_DATA_CFG) ;
-}
-
-#if 0
-static unsigned int get_tcm_data(void)
-{
-	unsigned int data = readl(TCM_DATA_CFG);
-	return data;
-}
-#endif
-
 static unsigned int lpddr4_get_mr(void)
 {
-	int i = 0;
+	int i = 0, j = 5 ;
 	unsigned int ddr_info = 0;
 	unsigned int regs[] = { 5, 6, 7, 8 };
 
-	for ( i = 0 ; i < ARRAY_SIZE(regs) ; i++ ) {
-		unsigned int data = 0;
-		data = lpddr4_mr_read(0xF, regs[i]);
-		ddr_info <<= 8;
-		ddr_info += (data & 0xFF);
-	}
+	do {
+		for ( i = 0 ; i < ARRAY_SIZE(regs) ; i++ ) {
+			unsigned int data = 0;
+			data = lpddr4_mr_read(0xF, regs[i]);
+			ddr_info <<= 8;
+			ddr_info += (data & 0xFF);
+		}
+	if ( ddr_info != 0xFFFFFFFF )
+		break;
+	} while ( --j );
 	return	ddr_info;
 }
 
+static void spl_tcm_init(struct lpddr4_tcm_desc *lpddr4_tcm_desc) {
+    if (lpddr4_tcm_desc->sign == DEFAULT)
+	    return;
+
+    lpddr4_tcm_desc->sign = DEFAULT;
+    lpddr4_tcm_desc->index = 0;
+}
+
+static void spl_tcm_fini(struct lpddr4_tcm_desc *lpddr4_tcm_desc) {
+    if (lpddr4_tcm_desc->sign != DEFAULT)
+	    return;
+
+    lpddr4_tcm_desc->sign = ~DEFAULT;
+    lpddr4_tcm_desc->index = 0;
+}
+
+#define SPL_TCM_DATA 0x7e0000
+#define SPL_TCM_INIT spl_tcm_init(lpddr4_tcm_desc)
+#define SPL_TCM_FINI spl_tcm_fini(lpddr4_tcm_desc)
+
 void spl_dram_init(void)
 {
 	unsigned int ddr_info = 0xdeadbeef;
 	unsigned int ddr_info_mrr = 0xdeadbeef;
-	unsigned int ddr_drate_index = 0;
 	unsigned int ddr_asize = 0;
+	unsigned int ddr_found = 0;
 	int i = 0, j = 0;
 
 	const struct lpddr4_desc *lpddr4_array = NULL;
+	struct lpddr4_tcm_desc *lpddr4_tcm_desc = (struct lpddr4_tcm_desc *) SPL_TCM_DATA;
 
 	if ((get_cpu_rev() & 0xfff) == CHIP_REV_2_1) {
 		lpddr4_array = lpddr4_array_3op;
@@ -119,85 +119,79 @@ void spl_dram_init(void)
 		ddr_asize = ARRAY_SIZE(lpddr4_array_2op);
 	}
 
-	/* get ddr type from the eeprom */
-	ddr_info = cl_eeprom_get_ddrinfo();
-	for ( i = 0; i < ddr_asize ; i++ ) {
-		if (lpddr4_array[i].id == DEFAULT)
-			break;
-		if (lpddr4_array[i].id == ddr_info)
-			break;
-	}
-
-	ddr_drate_index = cl_eeprom_get_drate(0,0);
-	/* index bound checker */
-	if (!(( ddr_drate_index  >= 0 ) && (  ddr_drate_index < lpddr4_array[i].count ))) {
-		/* if out of range, then set the default and update the eeprom */
-		ddr_drate_index = lpddr4_array[i]._default;
-		cl_eeprom_set_drate(ddr_drate_index, 0, 0);
+	if (lpddr4_tcm_desc->sign != DEFAULT) {
+		/* get ddr type from the eeprom if not in tcm scan mode */
+		ddr_info = cl_eeprom_get_ddrinfo();
+		for ( i = 0; i < ddr_asize ; i++ ) {
+			if (lpddr4_array[i].id == ddr_info) {
+				ddr_found = 1;
+				break;
+			}
+		}
 	}
 
-	/* At this point the ddr_drate_index is valid, either from eeprom or from the default field */
-	j = ddr_drate_index;
+	/* Walk trought all available ddr ids and apply
+	 * one by one. Save the index at the tcm memory that
+	 * persists after the reset.
+	 */
+	if (ddr_found == 0) {
+
+		SPL_TCM_INIT;
+
+		if (lpddr4_tcm_desc->index < ddr_asize) {
+			printf("DDRINFO: Cfg attempt: [ %d/%d ]\n", lpddr4_tcm_desc->index+1, ddr_asize);
+			i = lpddr4_tcm_desc->index;
+			lpddr4_tcm_desc->index += 1;
+		} else {
+			/* Ran out all available ddr setings */
+			printf("DDRINFO: Run out all [ %d ] cfg attempts. A non supported configuration.\n", ddr_asize);
+			while ( 1 ) {};
+		}
+		ddr_info = lpddr4_array[i].id;
+	} else
+		j = cl_eeprom_get_drate(0,0) % lpddr4_array[i].count;
 
-	printf("DDRINFO: %s %dG @ %d MHz\n",lpddr4_array[i].name,
+	printf("DDRINFO(%s): %s %dG @ %d MHz\n", (ddr_found ? "D" : "?" ), lpddr4_array[i].name,
 			lpddr4_array[i].size, lpddr4_array[i].timing[j]->fsp_table[0]);
 
-	if ( (lpddr4_array[i].count > 1 ) && (lpddr4_array[i].id != DEFAULT)  && spl_ddr_cfg_mode() )  {
-		printf("DDRINFO: DRAM Data Rates");
-
-		for ( j = 0; j < lpddr4_array[i].count ; j++ ) {
-			printf(": %d - [ %d ] ", j , lpddr4_array[i].timing[j]->fsp_table[0]);
-			if (lpddr4_array[i].desc[j])
-				printf(" ( %s ) ",  lpddr4_array[i].desc[j]);
-		}
+	ddr_init(lpddr4_array[i].timing[j]);
 
-		printf("\nDDRINFO: Wait for input; EEPROM drate index [ %d ] > ", ddr_drate_index);
-		j = (getc() - 0x30);
+	ddr_info_mrr = lpddr4_get_mr();
+	if (ddr_info_mrr == 0xFFFFFFFF ) {
+		printf("DDRINFO(M): mr5-8 [ 0x%x ] is invalid; reset\n", ddr_info_mrr);
+		SPL_TCM_INIT;
+		do_reset(NULL,0,0,NULL);
+	}
 
-		/* input index bound checker, if invalid then set the one from the eeprom */
-		if (!(( j >= 0 ) && ( j < lpddr4_array[i].count )))
-			j = ddr_drate_index;
+	printf("DDRINFO(M): mr5-8 [ 0x%x ]\n", ddr_info_mrr);
+	printf("DDRINFO(%s): mr5-8 [ 0x%x ]\n", (ddr_found ? "E" : "T" ), ddr_info);
 
-		/* save the new data rate index if got changed */
-		if (j != ddr_drate_index)
-			cl_eeprom_set_drate(j, 0, 0);
+	if (ddr_info_mrr != ddr_info) {
+		SPL_TCM_INIT;
+		do_reset(NULL,0,0,NULL);
 	}
 
-	ddr_init(lpddr4_array[i].timing[j]);
-
-	ddr_info_mrr = lpddr4_get_mr();
+	SPL_TCM_FINI;
 
-	if (ddr_info_mrr != ddr_info) {
-		/* save new ddr mr5-8 values */
-		printf("DDRINFO(M): mr5-8 [ 0x%x ]\n", ddr_info_mrr);
-		printf("DDRINFO(E): mr5-8 [ 0x%x ]\n", ddr_info);
+	if (ddr_found == 0) {
+		/* Update eeprom */
 		cl_eeprom_set_ddrinfo(ddr_info_mrr);
 		ddr_info = cl_eeprom_get_ddrinfo();
 		/* make sure that the ddr_info has reached the eeprom */
 		printf("DDRINFO(E): mr5-8 [ 0x%x ], read back\n", ddr_info);
-		if (ddr_info_mrr == ddr_info)
-			do_reset(NULL,0,0,NULL);
-		printf("DDRINFO(EEPROM): make sure that the eeprom is accessible\n");
-		printf("DDRINFO(EEPROM): i2c dev 1; i2c md 0x51 0x40 0x50\n");
-	}
-
-	if (lpddr4_array[i].id == DEFAULT)
-		printf("DDRINFO: mr5-8 [ 0x%x ]\n", ddr_info_mrr);
-	else for ( j = 0; j < lpddr4_array[i].count ; j++ ) {
-		/* Save/update available drates' values at the DRATE_OFFSET + 0x10 + ( j << 2 ) */
-		unsigned int _ddr_drate = cl_eeprom_get_drate(1,j);
-		if (lpddr4_array[i].timing[j]->fsp_table[0] != _ddr_drate)
-			cl_eeprom_set_drate(lpddr4_array[i].timing[j]->fsp_table[0], 1, j);
+		if (ddr_info_mrr != ddr_info) {
+			printf("DDRINFO(EEPROM): make sure that the eeprom is accessible\n");
+			printf("DDRINFO(EEPROM): i2c dev 1; i2c md 0x51 0x40 0x50\n");
+		}
 	}
 
 	/* Pass the dram size to th U-Boot through the tcm memory */
 	{ /* To figure out what to store into the TCM buffer */
 	  /* For debug purpouse only. To override the real memsize */
-		unsigned int _ddr_osize = cl_eeprom_get_osize();
-		if ((_ddr_osize != 0) && (_ddr_osize != -1))
-			set_tcm_data(_ddr_osize);
-		else
-			set_tcm_data(lpddr4_array[i].size);
+		unsigned int ddr_tcm_size = cl_eeprom_get_osize();
+		if ((ddr_tcm_size == 0) || (ddr_tcm_size == -1))
+			ddr_tcm_size = lpddr4_array[i].size;
 
+		lpddr4_tcm_desc->size = ddr_tcm_size;
 	}
 }
-- 
1.9.1

